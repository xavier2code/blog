<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://xavier2code.site name=base><title>
            
                Lifetimes in Rust
            
        </title><meta content="Lifetimes in Rust" property=og:title><link href=https://xavier2code.site/favicon.png rel=icon type=image/png><link href=https://xavier2code.site/fonts.css rel=stylesheet><script async data-goatcounter=https://xavier2code.goatcounter.com/count src=https://xavier2code.site/js/count.js></script><noscript><img src="https://xavier2code.goatcounter.com//count?p=/posts/rust2/&t=Lifetimes in Rust"></noscript><script defer src=https://xavier2code.site/js/codeblock.js></script><script src=https://xavier2code.site/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=https://xavier2code.site/atom.xml rel=alternate title=xavier2code type=application/atom+xml><link href=https://xavier2code.site/theme/light.css rel=stylesheet><link href=https://xavier2code.site/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://xavier2code.site/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://xavier2code.site/main.css media=screen rel=stylesheet><script src="https://xavier2code.site/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=left-content></div><div class=content><nav><div class=left-nav><a href=https://xavier2code.site>xavier2code</a><div class=socials><a class=social href=https://mail.google.com/ rel=me> <img alt=email src=https://xavier2code.site/icons/social/email.svg> </a><a class=social href=https://github.com/xavier2code/ rel=me> <img alt=github src=https://xavier2code.site/icons/social/github.svg> </a><a class=social href=https://discord.com/ rel=me> <img alt=discord src=https://xavier2code.site/icons/social/discord.svg> </a><a class=social href=https://www.reddit.com/ rel=me> <img alt=reddit src=https://xavier2code.site/icons/social/reddit.svg> </a><a class=social href=https://x.com/ rel=me> <img alt=x-twitter src=https://xavier2code.site/icons/social/x-twitter.svg> </a></div></div><div class=right-nav><a href=https://xavier2code.site/posts style=margin-right:.5em>/posts</a><a href=https://xavier2code.site/projects style=margin-right:.5em>/projects</a><a href=https://xavier2code.site/archive style=margin-right:.5em>/archive</a><a href=https://xavier2code.site/about style=margin-right:.5em>/about</a><a href=https://xavier2code.site/tags style=margin-right:.5em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://xavier2code.site/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://xavier2code.site/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://xavier2code.site/icons/moon.svg> </a><script>updateItemToggleTheme()</script></div></nav><div data-selector="main article p" class=visible-element-observer-root><main><article><div class=title><div class=page-header>Lifetimes in Rust</div><div class=meta>Posted on <time>2025-02-05</time><span class=tags-label> :: </span><span class=tags> <a class=post-tag href=https://xavier2code.site/tags/documentation/>documentation</a> <a class=post-tag href=https://xavier2code.site/tags/rust/>rust</a> </span></div></div><section class=body><h2 id=the-concept-of-lifetimes><a aria-label="Anchor link for: the-concept-of-lifetimes" class=zola-anchor href=#the-concept-of-lifetimes>The Concept of Lifetimes</a></h2><p>In Rust, lifetimes are a mechanism used by the compiler to ensure that all references are valid while they are in use. Lifetimes help prevent dangling references and data races. Lifetime annotations are used to explicitly inform the compiler about the lifetimes of references so that it can perform checks at compile time. Lifetimes are typically denoted by symbols such as 'a, 'b, etc. These symbols are generic lifetime parameters that describe the relationships between the lifetimes of references.<h2 id=the-difference-between-lifetimes-and-scopes><a aria-label="Anchor link for: the-difference-between-lifetimes-and-scopes" class=zola-anchor href=#the-difference-between-lifetimes-and-scopes>The Difference Between Lifetimes and Scopes</a></h2><ul><li>Scope: The range in the code where a variable or reference is valid.<li>Lifetime: The duration for which a reference is valid relative to the data it borrows.</ul><p>Example:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>main</span><span>() {
</span><span>  </span><span style=color:#fa6e32>let</span><span> s1 </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>String</span><span style=color:#ed9366>::</span><span>from(</span><span style=color:#86b300>"hello"</span><span>)</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>let</span><span> r </span><span style=color:#ed9366>= &</span><span>s1</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// The lifetime of `r` begins
</span><span>  </span><span style=color:#f07171>println!</span><span>(</span><span style=color:#86b300>"</span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,</span><span> r)</span><span style=color:#61676ccc>;
</span><span>} </span><span style=color:#abb0b6;font-style:italic>// The lifetime of `r` ends, and the scope of `s1` ends
</span></code></pre><p>In this example, the scope of s1 is the entire main function, while the lifetime of r is a subset of s1's scope.<h2 id=applications-of-lifetimes><a aria-label="Anchor link for: applications-of-lifetimes" class=zola-anchor href=#applications-of-lifetimes>Applications of Lifetimes</a></h2><h3 id=lifetimes-in-functions><a aria-label="Anchor link for: lifetimes-in-functions" class=zola-anchor href=#lifetimes-in-functions>Lifetimes in Functions</a></h3><p>When a function returns a reference, it is necessary to explicitly annotate the lifetime to ensure that the returned reference is valid within the caller's scope.<p>Example:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>longest</span><span>&lt;</span><span style=color:#fa6e32>'a</span><span>>(</span><span style=color:#ff8f40>x</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a str</span><span>, </span><span style=color:#ff8f40>y</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a str</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a str </span><span>{
</span><span>  </span><span style=color:#fa6e32>if</span><span> x</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>() </span><span style=color:#ed9366>></span><span> y</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>() {
</span><span>    x
</span><span>  } </span><span style=color:#fa6e32>else </span><span>{
</span><span>    y
</span><span>  }
</span><span>}
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>main</span><span>() {
</span><span>  </span><span style=color:#fa6e32>let</span><span> string1 </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>String</span><span style=color:#ed9366>::</span><span>from(</span><span style=color:#86b300>"long string is long"</span><span>)</span><span style=color:#61676ccc>;
</span><span>  {
</span><span>    </span><span style=color:#fa6e32>let</span><span> string2 </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>String</span><span style=color:#ed9366>::</span><span>from(</span><span style=color:#86b300>"xyz"</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> result </span><span style=color:#ed9366>= </span><span style=color:#f07171>longest</span><span>(string1</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_str</span><span>()</span><span style=color:#61676ccc>,</span><span> string2</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_str</span><span>())</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>println!</span><span>(</span><span style=color:#86b300>"The longest string is </span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,</span><span> result)</span><span style=color:#61676ccc>;
</span><span>  }
</span><span>}
</span></code></pre><p>In this example, the longest function's return value's lifetime is associated with the lifetimes of the input parameters x and y. The compiler ensures that the returned reference is valid within the caller's scope.<h3 id=lifetimes-in-structs><a aria-label="Anchor link for: lifetimes-in-structs" class=zola-anchor href=#lifetimes-in-structs>Lifetimes in Structs</a></h3><p>When a struct contains references, it is necessary to explicitly annotate the lifetime to ensure the validity of the struct instance.<p>Example:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>struct </span><span style=color:#399ee6>Book</span><span>&lt;</span><span style=color:#fa6e32>'a</span><span>> {
</span><span>  title</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a str</span><span>,
</span><span>  author</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a str</span><span>,
</span><span>}
</span><span>
</span><span style=color:#fa6e32>impl</span><span>&lt;</span><span style=color:#fa6e32>'a</span><span>> </span><span style=color:#399ee6>Book</span><span>&lt;</span><span style=color:#fa6e32>'a</span><span>> {
</span><span>  </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>new</span><span>(</span><span style=color:#ff8f40>title</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a str</span><span>, </span><span style=color:#ff8f40>author</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a str</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{
</span><span>    Book { title</span><span style=color:#61676ccc>,</span><span> author }
</span><span>  }
</span><span>
</span><span>  </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>get_title</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'a str </span><span>{
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>title
</span><span>  }
</span><span>}
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>main</span><span>() {
</span><span>  </span><span style=color:#fa6e32>let</span><span> title </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>String</span><span style=color:#ed9366>::</span><span>from(</span><span style=color:#86b300>"The Rust Programming Language"</span><span>)</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>let</span><span> author </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>String</span><span style=color:#ed9366>::</span><span>from(</span><span style=color:#86b300>"Steve Klabnik and Carol Nichols"</span><span>)</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>let</span><span> book </span><span style=color:#ed9366>= </span><span>Book</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#ed9366>&</span><span>title</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>author)</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#f07171>println!</span><span>(</span><span style=color:#86b300>"Book title: </span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,</span><span> book</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_title</span><span>())</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>In this example, the Book struct contains two string slice references. The lifetime 'a ensures that the Book instance exists within the validity period of the references.<h3 id=lifetime-elision-rules><a aria-label="Anchor link for: lifetime-elision-rules" class=zola-anchor href=#lifetime-elision-rules>Lifetime Elision Rules</a></h3><p>In some cases, the Rust compiler can automatically infer lifetimes, thus omitting explicit annotations.<p>Example:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>first_word</span><span>(</span><span style=color:#ff8f40>s</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str </span><span>{
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// Implementation
</span><span>}
</span><span>
</span></code></pre><p>In this example, although lifetimes are not explicitly annotated, the compiler infers that the input and output references have the same lifetime based on the elision rules.<h2 id=summary><a aria-label="Anchor link for: summary" class=zola-anchor href=#summary>Summary</a></h2><p>Lifetimes are an important concept in Rust, used to ensure that references are always valid while in use. By explicitly annotating lifetimes, the validity period of references can be clearly defined, preventing dangling references and data races. Explicit lifetime annotations are key to ensuring the safety of code in functions and structs.</section></article></main></div><div class=giscus></div><script async crossorigin issue-term=pathname label=Comment repo=xavier2code/blog src=https://utteranc.es/client.js theme=preferred-color-scheme></script></div><div class=right-content></div>